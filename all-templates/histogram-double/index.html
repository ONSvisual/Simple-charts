<!DOCTYPE html>
<html lang="en">
<!-- TEMPLATE https://github.com/ONSvisual/Simple-charts/tree/master/all-templates/histogram-double -->

<head>
	<link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
	<title>Histogram, double</title>
	<meta name="description" content="">
	<meta http-equiv="X-UA-Compatible" content="IE=edge" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <meta name="robots" content="noindex" />
  <meta name="googlebot" content="indexifembedded" />

	<link rel="stylesheet" href="../lib/globalStyle.css" />
	<style>
		b {
			margin-top: 0px !important;
			width: 15px !important;
			border-style: solid;
			border-width: 2px;
		}

		h6 {
			font-size: 16px;
			margin: 16px 0 8px 0;
			font-weight: 700;
			color: #323132;
		}
	</style>
</head>

<body>

	<div class="visuallyhidden">
		<h5 id="screenreadertext">The chart canvas is hidden from screen readers. The main message is summarised by the
			chart title and the data behind the chart is available to download below.</h5>
	</div>
	<div id="graphic" aria-hidden="true">
	</div>

	<h6 id="source"></h6>

	<div id="keypoints" aria-hidden="true">
		<p></p>
	</div>

	<script src="https://cdn.ons.gov.uk/vendor/d3/4.2.7/d3.min.js"></script>
	<script src="../lib/modernizr.svg.min.js"></script>
	<script src="https://cdn.ons.gov.uk/vendor/pym/1.3.2/pym.min.js"></script>
	<script src="config.js"></script>

	<script>

		var graphic = d3.select('#graphic');
		var keypoints = d3.select('#keypoints');
		var footer = d3.select(".footer");
		var pymChild = null;

		function drawGraphic(width) {
			var threshold_md = 788;
			var threshold_sm = dvc.optional.mobileBreakpoint;

			//set variables for chart dimensions dependent on width of #graphic
			if (parseInt(graphic.style("width")) < threshold_sm) {
				var margin = { top: dvc.optional.margin_sm[0], right: dvc.optional.margin_sm[1], bottom: dvc.optional.margin_sm[2], left: dvc.optional.margin_sm[3] };
				var chart_width = parseInt(graphic.style("width")) - margin.left - margin.right;
				var height = Math.ceil((chart_width * dvc.optional.aspectRatio_sm[1]) / dvc.optional.aspectRatio_sm[0]) - margin.top - margin.bottom;
			} else if (parseInt(graphic.style("width")) < threshold_md) {
				var margin = { top: dvc.optional.margin_md[0], right: dvc.optional.margin_md[1], bottom: dvc.optional.margin_md[2], left: dvc.optional.margin_md[3] };
				var chart_width = parseInt(graphic.style("width")) - margin.left - margin.right;
				var height = Math.ceil((chart_width * dvc.optional.aspectRatio_md[1]) / dvc.optional.aspectRatio_md[0]) - margin.top - margin.bottom;
			} else {
				var margin = { top: dvc.optional.margin_lg[0], right: dvc.optional.margin_lg[1], bottom: dvc.optional.margin_lg[2], left: dvc.optional.margin_lg[3] }
				var chart_width = parseInt(graphic.style("width")) - margin.left - margin.right;
				var height = Math.ceil((chart_width * dvc.optional.aspectRatio_lg[1]) / dvc.optional.aspectRatio_lg[0]) - margin.top - margin.bottom;
			}

			// clear out existing graphics
			graphic.selectAll("*").remove();
			keypoints.selectAll("*").remove();
			footer.selectAll("*").remove();

			if (dvc.essential.screenreadertext != "") {
				d3.select("#screenreadertext").text(dvc.essential.screenreadertext)
			}

			var x = d3.scaleLinear()
				.range([0, chart_width]);


			var y = d3.scaleLinear()
				.range([height, 0]);

			var xDomain = dvc.essential.xAxisScale
			x.domain(xDomain)


			var xAxis = d3.axisBottom(x)

			var yAxis = d3.axisLeft(y);

			//create legend 
			var legend = d3.select('#graphic')
				.append('ul')
				.attr('class', 'key')
				.selectAll('g')
				.data(dvc.essential.legendLabels)
				.enter().append('li')
				.attr("class", function (d, i) {
					return "key-" + i
				})

			legend.append('b')
				.style('background-color', function (d, i) {
					if (i == 0)
						return dvc.essential.colour_palette
					else
						return dvc.essential.negative_colour
				})
				.style("border-color", function (d, i) {
					if (i == 0)
						return dvc.essential.stroke_colour
					else
						return dvc.essential.negative_stroke
				})
			legend.append('label')
				.html(function (d, i) {
					return dvc.essential.legendLabels[i];
				});


			//specify number or ticks on y axis
			if (parseInt(graphic.style("width")) <= threshold_sm) {
				yAxis.ticks(dvc.optional.y_num_ticks_sm_md_lg[0])
			} else if (parseInt(graphic.style("width")) <= threshold_md) {
				yAxis.ticks(dvc.optional.y_num_ticks_sm_md_lg[1])
			} else {
				yAxis.ticks(dvc.optional.y_num_ticks_sm_md_lg[2])
			}

			//gridlines
			var y_axis_grid = function () { return yAxis; }

			// parse data into columns
			var bars = {};


			//y domain calculations	: zero to intelligent max choice, or intelligent min and max choice,  or interval chosen manually
			if (dvc.essential.yAxisScale == "auto_zero_max") {
				var yDomain = [
					0,
					d3.max(d3.entries(bars), function (c) {
						return d3.max(c.value, function (v) {
							var n = v.amt;
							return Math.ceil(n);
						});
					})
				];
			} else if (dvc.essential.yAxisScale == "auto_min_max") {
				var yDomain = [
					d3.min(d3.entries(bars), function (c) {
						return d3.min(c.value, function (v) {
							var n = v.amt;
							return Math.floor(n);
						});
					}),

					d3.max(d3.entries(bars), function (c) {
						return d3.max(c.value, function (v) {
							var n = v.amt;
							return Math.ceil(n);
						});
					})
				];
			} else {
				var yDomain = dvc.essential.yAxisScale;
			}

			y.domain(yDomain);



			//create svg for chart
			var svg = d3.select('#graphic').append('svg')
				.attr("id", "chart")
				.style("background-color", "#fff")
				.attr("width", chart_width + margin.left + margin.right)
				.attr("height", height + margin.top + margin.bottom + 30)
				.append("g")
				.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

			svg.append('g')
				.attr('class', 'y axis')
				.call(yAxis.tickSize(-chart_width, 0))



			//create x axis, if y axis doesn't start at 0 drop x axis accordingly
			svg.append('g')
				.attr('class', 'x axis')
				.attr('transform', function (d) {
					if (yDomain[0] != 0) {
						return 'translate(0,' + (height + 30) + ')'
					} else {
						return 'translate(0,' + height + ')'
					}
				})
				.call(xAxis);

			d3.select(".x")
				.select("path")
				.style("stroke", "#666")

			//create icon to symbolise break in y axis if required
			if (yDomain[0] > 0 && dvc.essential.yAxisBreak == true) {
				var paths = svg.append("defs")
					.append("g")
					.attr("id", "icon")
					.append("g");

				paths.append("polyline")
					.attr("points", "2.881,9.54 7.94,5.061 12.341,9.54 17.77,5.061")
					.attr("stroke", "#666")
					.attr("fill", "none")
				paths.append("polyline")
					.attr("points", "2.881,14.54 7.94,10.061 12.341,14.54 17.77,10.061")
					.attr("stroke", "#666")
					.attr("fill", "none");

				//specify position of icon
				svg.append("g").attr("id", "iconpath")
					.attr("transform", "translate(-10,3)")
					.append("use")
					.attr("xlink:href", "#icon")
					.attr("x", x(x.domain()[0]))
					.attr("y", function () {
						if (parseInt(graphic.style("width")) < threshold_sm) {
							return y(dvc.essential.yAxisBreak_sm_md_lg[0])
						} else if (parseInt(graphic.style("width")) < threshold_md) {
							return y(dvc.essential.yAxisBreak_sm_md_lg[1])
						} else {
							return y(dvc.essential.yAxisBreak_sm_md_lg[2])
						}
					});
			}



			//create centre line if required
			if (dvc.optional.centre_line == true) {
				svg.append("line")
					.attr("id", "centreline")
					.attr('y1', y(dvc.optional.centre_line_value))
					.attr('y2', y(dvc.optional.centre_line_value))
					.attr('x1', 0)
					.attr('x2', chart_width);
			} else if (yDomain[0] < 0) {
				svg.append("line")
					.attr("id", "centreline")
					.attr('y1', y(0))
					.attr('y2', y(0))
					.attr('x1', 0)
					.attr('x2', chart_width);
			}

			graphic_data.forEach(function (d, i) {
				svg.append("rect")
					.attr("x", x(d.from))
					.attr("y", y(d.count))
					.attr("height", y(0) - y(d.count))
					.attr("width", x(d.to) - x(d.from) + 0.16)
					.style("fill", dvc.essential.colour_palette)
					.style("stroke", dvc.essential.stroke_colour)
			})

			graphic_data.forEach(function (d, i) {
				svg.append("rect")
					.attr("x", x(d.from))
					.attr("y", y(d.count2))
					.attr("height", y(0) - y(d.count2))
					.attr("width", x(d.to) - x(d.from) + 0.16)
					.style("fill", dvc.essential.negative_colour)
					.style("stroke", dvc.essential.negative_stroke)
			})

			writeAnnotation();

			function writeAnnotation() {

				if (parseInt(graphic.style("width")) < threshold_sm) {

					dvc.essential.annotationBullet.forEach(function (d, i) {

						d3.select("#keypoints").append("svg")
							.attr("width", "20px")
							.attr("height", "20px")
							.attr("class", "circles")
							.append("circle")
							.attr("class", "annocirc" + (i))
							.attr("r", "2")
							.attr('cy', "12px")
							.attr("cx", "10px");

						d3.select("#keypoints")
							.append("p")
							.style("font-size", "16px")
							.style("font-weight", 400)
							.text(dvc.essential.annotationBullet[i]);

					})// end foreach
				}
				else {

					dvc.essential.annotationChart.forEach(function (d, i) {

						// draw annotation text based on content of var annotationArray ...
						svg.append("text")
							.text(dvc.essential.annotationChart[i])
							.attr("class", "annotext" + i)
							.attr("text-anchor", dvc.essential.annotationAlign[i])
							.attr('y', y(dvc.essential.annotationXY[i][1]))
							.attr('x', x(dvc.essential.annotationXY[i][0]));

						d3.selectAll(".annotext" + (i))
							.attr('font-size', '13px')
							.attr("fill", "#666")
							.attr("font-size", "13px")
							.attr("font-weight", 500)
							.each(insertLinebreaks)
							.each(createBackRect);


						function insertLinebreaks() {

							var str = this;

							var el1 = dvc.essential.annotationChart[i];
							var el = el1.data;

							var words = el1.split('  ');

							d3.select(this/*str*/).text('');

							for (var j = 0; j < words.length; j++) {
								var tspan = d3.select(this).append('tspan').text(words[j]);
								if (j > 0)
									tspan.attr('x', x(dvc.essential.annotationXY[i][0])).attr('dy', '22');
							}
						};

						function createBackRect() {

							var BBox = this.getBBox()

							svg.insert("rect", ".annotext" + (i))
								.attr("width", BBox.width)
								.attr("height", BBox.height)
								.attr("x", BBox.x)
								.attr("y", BBox.y)
								.attr("fill", "white")
								.attr("opacity", 0.4);

						}; // end function createBackRect()


					});	// end foreach

				} // end else ...

				return;

			}// end function writeAnnotation()

			if (dvc.optional.vertical_line == true) {
				dvc.optional.annotateLineX1_Y1_X2_Y2.forEach(function (d, i) {
					svg.append("line")
						.attr('x1', x(dvc.optional.annotateLineX1_Y1_X2_Y2[i][0][0]))
						.attr('x2', x(dvc.optional.annotateLineX1_Y1_X2_Y2[i][1][0]))
						.style('stroke', '#888')
						.style('stroke-width', 2)
						.attr('y2', y(dvc.optional.annotateLineX1_Y1_X2_Y2[i][1][1]));
				})
			}

			svg.append("text")
				.attr('class', 'unit')
				.attr('transform', "translate(" + eval(-margin.left + chart_width - 5) + "," + eval((-margin.bottom + height) + 85) + ")")
				.attr("font-size", "16px")
				.attr("fill", "#666")
				.text(function (d, i) { return dvc.essential.xAxisLabel });

			if (dvc.optional.annotateRect == true) {

				dvc.optional.annotateRectX_Y.forEach(function (d, i) {

					svg.append("rect")
						.attr('x', x(dvc.optional.annotateRectX_Y[i][0][0]))
						.attr('y', y(dvc.optional.annotateRectX_Y[i][0][1]))
						.attr('height', y(dvc.optional.annotateRectX_Y[i][1][1]) - y(dvc.optional.annotateRectX_Y[i][0][1]))
						.attr('width', x(dvc.optional.annotateRectX_Y[i][1][0]) - x(dvc.optional.annotateRectX_Y[i][0][0]))
						.style('fill', dvc.optional.rectStyle[i][0])
						.style('stroke-width', 2)
						.style('opacity', dvc.optional.rectStyle[i][1]);

				})
			}

			d3.select('#source')
				.text('Source: ' + dvc.essential.sourceText);

			lineNo = 0;

			svg.append("text")
				.attr('class', 'unit')
				.attr('transform', "translate(" + -margin.left + "," + eval(-margin.top + (lineNo + 0.45) * 20) + ")")
				.attr("font-size", "16px")
				.attr("fill", "#666")
				.text(function (d, i) { return dvc.essential.yAxisLabel });




			d3.selectAll("path").attr("fill", "none");

			d3.selectAll("text").attr("font-family", "'Open Sans', sans-serif");

			d3.selectAll(".y text").attr("font-size", "14px").attr("fill", "#666");
			d3.selectAll(".x text").attr("font-size", "14px").attr("fill", "#666"); // dates - timelines

			d3.selectAll(".y line")
				.attr("stroke", "#CCC")
				.attr("stroke-width", "1px")
				.style("shape-rendering", "crispEdges");

				d3.selectAll("text")
				.style("font-family","Open Sans")

			//use pym to calculate chart dimensions
			if (pymChild) {
				pymChild.sendHeight();
			}
		}

		//check whether browser can cope with svg
		if (Modernizr.svg) {
			//load chart data
			d3.csv(dvc.essential.graphic_data_url, function (error, data) {
				graphic_data = data;


				//use pym to create iframed chart dependent on specified variables
				pymChild = new pym.Child({ renderCallback: drawGraphic });
			});


		} else {
			//use pym to create iframe containing fallback image (which is set as default)
			pymChild = new pym.Child();
			if (pymChild) {
				pymChild.sendHeight();
			}
		}
	</script>
</body>

</html>